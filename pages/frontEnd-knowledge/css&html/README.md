# 임시 정리 공간

***
| 중요도 | 설명 |   
| :------ |:--- |  
| ★★★★★ | 프론트 개발자라면 무조건 알아야 되는 지식이다. 이걸 모르면 프론트 개발자라고 하면안된다.|
| ★★★★ | 최소 10개 중 8개는 알아야 되는 지식이다. 프론트엔드 개발자라면 필수.|
| ★★★ | 몰라도 되지만 알면 좋은 지식들|



## 1. 이벤트 버블링, 이벤트 캡쳐링, 이벤트 위임이란? ★★★★★

### 이벤트 버블링
* 특정 화면 요소에서 이벤트가 발생하면 해당 이벤트가 하위에서 상위 요소로 전달되는 것을 이벤트 버블링이라 합니다.

### 이벤트 캡쳐링
* 이벤트 버블링과는 반대로 상위 요소에서 하위 요소로 이벤트가 전달되는 것을 말합니다.
* 이벤트 캡처링을 하기위해서는 그냥 API옵션 객체에 `capture:true`를 설정하면됩니다.

### 이벤트 위임
* 요소 하나하나를 이벤트를 부여할게 아니라, 하나의 부모에 이벤트를 등록하면 해당 부모가 자식 요소들에게 이벤트를 위임하는 방식을 이벤트 위임이라고 합니다.
* 만약에 위임을 막고 싶다면 event.stopPropagation(), 이벤트 스탑프로페이제이션()를 사용합니다. 캡쳐링의 경우 클릭한 상위요소만 이벤트가 발생하고 하위 요소들한테는 이벤트를 전파하지 않습니다.

### 

<br>

## 2. this란 무엇인가? ★★★★★
* this는 자바스크립트 런타임시 바인딩이 이루어지는 실행 컨텍스트 중 하나입니다.
* 보통 객체와 관련이 깊고, 함수 호출 부분에서 this가 가르키는게 컨텍스트 객체가 무엇인지 확인할 수 있습니다.
* this는 전역 문맥에서 사용하면 글로벌 객체를 참조하고, 함수 호출 방법에 따라 this가 가르키는 컨텍스트 객체가 다릅니다.
* 함수 호출 방법으로는 메서드로서 호출되는 방법과, call, apply, bind 메서드로 호출되는 방법, 생성자(New) 함수 호출

<br>

## 3. 호이스팅 ★★★★★
* 호이스팅은 코드를 실행하기 전 실행 컨텍스트를 위한 과정에서 모든 선언(var, let, const, function, class)을 스코프의 최상단으로 끌어 올려진 것 같은 현상을 말합니다.
* 그렇기 때문에 코드 순서상 선언이 뒤에있어도 참조가 가능합니다. 단. var 키워드만 가능합니다
* const와 let도 호이스팅이 발생하지만 선언 이전에 참조하게 되면 참조에러가 발생합니다.
* 그 이유는 변수의 생성 단계 때문입니다.
* 변수의 생성단계는 선언단계->초기화단계->할당단계 로 이루어지는데 var는 선언과 초기화 단게를 동시에 진행합니다. 하지만, const와 let은 변수 선언문에 도달했을 때 초기화 단계가 이루어집니다.
* 그렇기 때문에 var 키워드는 변수 선언문 이전에 접근해도 에러가나지 않는것이죠 단 undefined를 반환합니다.

<br>

## 4. Callback과 Promise, async/await의 차이점 ★★★★★

### Callback
가장 먼저 나온 callback은 비동기 처리를 하기위해 만들어졌습니다. 이 함수는 다른 함수에게 인자로 전달되어 다시 호출하는 기능을 callback이라고 부릅니다.
하지만, 콜백 지옥이라 불리는 중첩문이 발생하게 되면서 이것을 해결하기 위해 Promise 생겼습니다.

### Promise
Promise도 기본적으로 callback과 하는 일은 똑같습니다. 다만 차이점이라면 Promise는 작업이 끝난 뒤에 실행할 함수를 호출하는 것이아니라 Promise 자체 메소드인 .then()을 호출합니다.
then() 메소드는 연속적으로 사용이 가능하기 때문에 중첩으로 사용해도 코드가 간결해서 이해하기도 쉽습니다.

또한, 성공, 실패, 오류에 따른 예외처리가 가능하기 때문에 가독성도 좋구 비동기 에러처리에도 수월합니다.

### Async/await
promise랑 기능은 똑같습니다. 최신에 등장한 문법으로 Async 키워드와 await 키워드를 항상 같이 사용해야 합니다.
await는  Promise 객체를 받아 처리하는 역할을 합니다. 그리고 결과값을 반환할때까지 기다리며 반환되면 다음으로 넘어갑니다.
Async는 Promise 객체를 통해 비동기적으로 처리된 내용을 동기적인 코드 진행 순서로 보여주는 역할을 한다.

보통, 비동기처리를 동기적으로 순차적으로 처리하고싶을 떄 사용합니다.

<br>

## 5. 브라우저 저장소에 대해서 차이점 설명(로컬스토리지, 세션스토리지, 쿠키) ★★★★★

브라우저 저장소는 로컬스토리지, 세션스토리지 있습니다.
기본적으로 브라우저 저장소는 key/value 쌍으로 데이터를 저장하고, key값으로 데이터를 조회할 수 있습니다.

### 쿠키
* 웹 사이트에서 쿠키를 설정하게되면 이후 모든 웹 요청은 쿠키를 포함하여 서버에 전송됩니다.
* 하지만 브라우저 저장소에 저장된 데이터는 클라이언트에만 존재하고 전송은 하지 않습니다.
* 또한, 쿠키는 저장 개수와 용량이 제한되어있습니다. 최대 저장 수는 20개입니다. 최대 용량은 4키로바이트 입니다.

### 로컬스토리지
* 데이터를 지우지 않는 이상 `영구적으로 보관`이 가능합니다.
* 그리고 도메인마다 로컬스토리지가 생성됩니다.
* 그리고 Windows 전역 객체의 로컬스토리지라는 컬렉션을 통해 저장과 조회가 가능합니다.

### 세션스토리지
* 로컬스토리지와는 다르게 `임시저장소`로 불립니다.
* 데이터의 지속성과 접근할 수 있는 범위의 제한이 존재합니다.
* 그리고 세션스토리지는 Windows 전역 객체의 세션스토리지라는 컬렉션을 통해 저장과 조회가 가능합니다.
* 세션스토리지는 현재 페이지의 브라우저 컨텍스트 내에서만 데이터가 유지되며, 브라우저가 종료되면 데이터도 같이 지워진다.

<br>

## 6. 자바스크립트의 동작원리 ★★★★★

* 자바스크립트는 싱글 스레드 기반이며, 구글의 V8엔진과 콜백 큐를 사용합니다.
* V8엔진은 크게 메모리 힙과 콜스택, 이 두 가지 요소로 구분됩니다. 
* 메모리힙은 정보를 저장하는 공간이고, 콜 스택에서는 코드 실행에 따라 호출 스택이 쌓입니다.
* 자바스크립트는 싱글 스레드 언어이기 때문에 콜스택은 하나만 있습니다. 그래서 한 번에 여러 개의 작업을 동시에 할 수 없으며 한 번에 한 작업만 처리할 수 있습니다.

### Callback Queue
* 자바스크립트는 비동기처리를 콜스택에 쌓지 않고 콜백 큐에 전달합니다.
* 콜백 큐는 대기하다가 콜 스택이 비어있으면 이벤트 루프를 돌려서 콜백함수를 스택에 넣습니다. 그런데 여기서 주의해야할 건 비동기처리가 완료되었더라도 스택이 비어있지 않으면 비어있을때 까지 무한대기합니다.
* 이벤트 루프의 기본 역할은 큐와 스택을 지켜보고 있다가 스택이 비는 시점에 콜백을 실행시켜 주는 것입니다.

<br>

## 7. 스코프 Scope ★★★★
자바스크립트는 3가지의 스코프 유형이 있습니다.
* 블록 스코프
* 함수 스코프
* 전역 스코프

기본적으로 자바스크립트는 함수레벨 스코프를 따릅니다. 함수 레벨 스코프는 함수내에 선언된 변수들은 함수내에서만 유효합니다. 즉, 외부에서는 참조할 수 없습니다.

하지만 es6 이후부터는 let, const가 등장하면서 블록 레벨 스코프를 제공합니다.

### 전역 스코프는
* 전역으로 선언된 변수는 전역 스코프를 가지며 어디에서나 접근할 수 있습니다.

### 함수 스코프는
* 함수 내에서 선언된 변수는 함수 외부에서는 접근할 수 없으며, 함수 내부에서만 접근할 수 있습니다.

### 블록 스코프는
* 블록 내부에 let과 const 키워드로 선언된 변수는 블록 내부에서만 접근가능하며 외부에서는 접근할 수 없습니다.
* 단 var 키워드는 블록 레벨 스코프를 가질 수 없습니다.

<br>

## 8. 프로토타입이란? ★★★★★
* 일단 자바스크립트는 객체지향언어입니다. 그런데 class라는 개념이 없습니다.
* 그래서, 기존의 객체를 복사하여 새로운 객체를 생성하는 프로토타입 기반의 언어입니다.
* ES6 이후 clss 문법이 생겼지만, 문법만 추가된것이지 class개념이 생긴게 아닙니다. new 통해 비슷하게 흉내는 낼 수 있습니다. 
* 객체를 상위 객체로부터 상속받고 그 상위 객체도 마찬가지입니다. 이를 프로토타입 체인이라 부릅니다.
* 자바스크립트에는 Prototype Link와 Prototype Object가 존재하는데 이 둘을 합쳐 프로토타입이라고 부릅니다.

### Prototype Object
객체는 언제나 함수(Function)로 생성됩니다. 이것이 무슨말이냐?

함수가 정의될 때 2가지 일이 발생합니다.
1. 해당 함수에 Constructor(생성자) 자격 부여한다.
    * Constructor 자격이 부여되면 new를 통해 객체를 만들어 낼 수 있게 됩니다. 이것이 함수만 new 키워드를 사용할 수 있는 이유입니다.

2. 해당 함수의 Prototype Object 생성 및 연결
    * 함수를 정의하면 함수만 생성되는것이 아니라 Prototype Object도 같이 생성합니다.

그리고 생성된 함수는 prototype이라는 속성을 통해 Prototype Object에 접근할 수 있습니다.
Prototype Object는 일반적인 객체와 같습니다. 또한 기본적인 속성으로 `constructor`, `__proto__`를 가지고 있습니다.

### Prototype Link
Prototype Object가 가지고 있는 속성인 `__proto__`가 바로 Prototype Link 입니다.
간단하게 말해 `__proto__`라는 속성은 객체가 생성될 때 조상이었던 함수의 `Prototype Object` 정보가 다들어있습니다.
이렇게 `__proto__`속성을 통해 상위 프로토타입과 연결되어있는 것을 `프로토타입 체인(Chain)`이라고 합니다.


<br>

## 9. var, let, const 차이 ★★★★
* let과 const 중복선언이 안되며, 블록 단위의 변수 타입입니다.
* let은 재할당이 가능하고, const는 중복선언과 재할당이 안되기 때문에 선언과 할당을 동시에 해야합니다.
* const는 재할당이 안된다고 했지만, 객체의 프로퍼티는 변경할 수 있습니다.
* 하지만 var는 동일한 이름을 갖는 변수를 몇 번이고 재선언할 수 있습니다.

<br>

<br>

## 10. 자바스크립트 데이터 타입 ★★★★
자바스크립트는 총 7가지의 데이터 타입을 가지고 있습니다. 
* Boolean 타입 : 논리 타입으로 true, false 두 가지 값을 가진다.
* Null 타입 : 존재하지 않는 빈값을 나타냅니다.
* Undefined 타입 : 값을 할당하지 않은 변수는 undefined 값을 가집니다.
* Number 타입 : 자바스크립트는 정수만을 위한 타입이 없고, 모든 수를 실수로 처리한다. 
* BigInt 타입 : Number와 유사하지만 Number보다는 범위가 더 크다. Number와 BigInt는 혼합해서 연산할 수 없다.
* String 타입 : 텍스트 데이터를 나타낼 때 사용합니다.
* Symbol 타입 : Symbol은 고유하고 변경 불가능한 원시 값이며 객체의 속성 키로 사용할 수 있습니다.